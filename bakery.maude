mod BAKERY is
    *** Imports
    including CONFIGURATION .
    protecting NAT .

    *** Sorts
    sorts GBState Mode .
    subsort Nat < Oid .

    *** Operations
    op [[_]] : Configuration -> GBState .
    ops sleep wait crit : -> Mode [ctor] .
    op initial : Nat -> GBState .
    op auxInitial : Nat -> Configuration .

    *** Classes
    --- class BProcess | mode: Mode, number: Nat .
    sort BProcess .
    subsort BProcess < Cid .
    op BProcess : -> BProcess .
    op mode:_ : Mode -> Attribute [gather (&)] .
    op number:_ : Nat -> Attribute [gather (&)] .

    --- class Dispenser | next: Nat, last: Nat .
    sort Dispenser .
    subsort Dispenser < Cid .
    op Dispenser : -> Dispenser .
    op next:_ : Nat -> Attribute [gather (&)] .
    op last:_ : Nat -> Attribute [gather (&)] .

    *** Vars
    vars N L : Nat .
    vars D P : Oid .
    var C : Configuration .

    *** Equations
    eq initial (N) = [[< 0 : Dispenser | next: 1 , last: 1 > auxInitial(N) ]] .
    eq auxInitial (0) = < 0 : BProcess | mode: sleep, number: 0 > .
    eq auxInitial (s N) = < N : BProcess | mode: sleep, number: 0 > auxInitial(N) .

    *** Rules
    rl [take-number] : 
    [[ < D : Dispenser | next: N, last: L > < P : BProcess | mode: sleep, number: 0 > C ]] 
    => 
    [[ < D : Dispenser | next: N, last: s L > < P : BProcess | mode: wait, number: L > C ]] .

    rl [get-atended] : 
    [[ < D : Dispenser | next: N, last: L > < P : BProcess | mode: wait, number: N > C ]] 
    => 
    [[ < D : Dispenser | next: N, last: L > < P : BProcess | mode: crit, number: N > C ]]  .

    rl [leave] : 
    [[ < D : Dispenser | next: N, last: L > < P : BProcess | mode: crit, number: N > C ]]
    => 
    [[ < D : Dispenser | next: s N, last: L > < P : BProcess | mode: sleep, number: 0 > C ]]  .
endm

mod ABSTRACT-BAKERY is
    protecting BAKERY .
    
    vars N L P D : Nat .
    var M : Mode .
    var C : Configuration .
    
    ceq < P : BProcess | mode: M, number: s(N) > = < P : BProcess | mode: M, number: N > if M == sleep = false .
    ceq < D : Dispenser | next: s N, last: s L > = < D : Dispenser | next: N, last: L > if N > s 0 .
endm
eof 

[Q1] rew initial(5) .

[Q2] search initial(5) =>* [[ < D : Dispenser | next: N, last: L > C]] .

[Q3] search initial(5) =>! [[ < 0 : Dispenser | next: N, last: L > C]] .